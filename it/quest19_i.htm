<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Інформаційні технології</TITLE>
</HEAD>
<BODY>
<FONT FACE="Tahoma" SIZE=4><p>
1.	Уніфікована мова моделювання UML. Види діаграм UML. Спрощена стратегія використання UML-діаграм при моделюванні програмних систем (ПС). Засоби розширення UML: стереотипи (stereotype), помічені значення (tagged value), обмеження (constraint). Профілі предметних областей. </p><p>
2.	Діаграми прецедентів. Моделювання контексту та вимог до ПС. Прецеденти, потоки подій та сценарії. Актори, основні актори. Відношення між акторами та прецедентами. Відношення узагальнення для прецедентів та акторів. Організація прецедентів, відношення включення (include) та розширення (extend). Варіанти діаграм прецедентів. </p><p>
3.	Реалізація прецедентів із використанням діаграм послідовностей та діаграм співробітництва (collaboration). Анатомія діаграм послідовності. Двоетапна розробка діаграм послідовностей та узгодженість (цілісність) моделей. Діаграми класів-учасників VOPC (View of Participating Classes) прецедентів. </p><p>
4.	Використання класів при проектуванні ПС. Класи етапу аналізу: прикордонні (boundary) або інтерфейсні класи, класи-сутності (entity), управляючі (control) класи (класи-менеджери). Класи етапу проектування. Відношення між класами та їх виявлення (узагальнення, залежність, асоціація, агрегація, композиція). Використання діаграм класів для кодогенерації. Кодогенерація та реінженіринг.</p><p>
5.	Діаграми класів та патерни проектування. Класифікація патернів: породжуючі, структурні, поведінкові. Приклади патернів: “Singleton”, “Adapter”, “Proxy”, “Decorator”.</p><p>
6.	Використання патерну “Proxy” в технологіях віддаленої взаємодії. Приклади.</p><p>
7.	Патерн “Builder” та його застосування в технологіях віддаленої взаємодії. Приклади.</p><p>
8.	Патерн DI/IOC та його застосування при розробці програмних проєктів.</p><p>
9.	Спрощена архітектура Java RMI. Особливості програмування RMI/JRMP-проектів. “Віддалені” інтерфейси та класи реалізації “віддалених” інтерфейсів. Розробка серверної та клієнтської програм на прикладі.</p><p> 
10.	Порівняння RMI/JRMP та RMI/IIOP варіантів віддаленої взаємодії, proxy-класи та їх отримання, використання “експортування” об'єктів, JRMP-IIOP портабельність Java RMI-проектів. </p><p>
11.	Типи об'єктів для віддаленої взаємодії із .NET Remoting. Варіанти конфігурування інфраструктури .NET Remoting. Приклади. </p><p>
12.	Серверна активізація, режими Singleton та SingleCall. Клієнтська активізація. Основи управління часом життя віддалених  об'єктів у . NET Remoting проєктах.</p><p>
13.	Веб-служби (Web Services) SOAP. Поняття сервісно-орієнтованої архітектури, мікросервіси. Стандарти веб-служб SOAP. Документування веб-служб, генерація html-сторінок, орієнтованих на сприйняття людиною. Тест-форми веб-служб.</p><p>
14.	WSDL  та універсальність технології SOAP веб-служб. Засоби для отримання proxy-класів веб-служб. </p><p> 
15.	Основи архітектури WCF. Кінцеві точки та контракти. Прив’язки, стандартні прив’язки. DataContract. Класи Behavior. Режими інстанціації (instance). </p><p>
16.	WCF та узагальнені веб-служби. Метадані WCF-служб. Сумісність служб ASMX та WCF, їх порівняння.</p><p>
17.	Ідеологія архітектурного стилю REST (REST веб-служб). Орієнтація на дані та їх репрезентація. Приклади.  Можливості тестування REST веб-служб. </p><p>
18.	REST веб-служби та ресурси з ієрархічною структурою. Приклади оперування такими ресурсами.  </p><p>
19.	Поняття HATEOAS та його використання. Моделі зрілості REST. Приклади.</p><p>
20.	OpenAPI Specification та cтруктура документів OpenAPI. Використання YAML та JSON. Swagger-інструменти та їх застосування.</p><p>
21.	Можливості отримання специфікації для вже існуючої реалізації, приклад. Swagger UI та можливості тестування проєктів.</p><p>
22.	Swagger-інструменти для кодогенерації серверних та клієнтських проєктів.</p><p> 
23.	Технологія GraphQL. Основні поняття та особливості. GraphQL як мова запитів для API, приклади запитів. </p><p>
24.	GraphQL-схеми та SDL. Приклади опису моделі. Запити та мутації, приклади опису. GraphQL схеми та графи. Запити рекурсивного характеру. </p><p>
25.	GraphQL «Resolver»-функції, їх призначення, розробка та використання. Приклади.</p><p>
26.	Технологія gRPC та її особливості. Структура protobuf-специфікації, опис класової моделі, опис сервісів. </p><p>
27.	Мовна підтримка технології gRPC, компілятор PROTOC, приклади використання кодогенерації. Приклади клієнтського та серверного проєктів, моливості тестувань.</p><p>
28.	Розробка Android-проектів в Android Studio. SDK Manager, Virtual Device Manager. Можливості візуального проектування. Активності (activities) та розмітки (layouts). Віджети та програмне оперування ними. Приклади.</p><p>
29.	Android Studio. Особливості розробки Android-проектів: використання ресурсних файлів та автоматично згенерованих Java-файлів. Приклади.</p><p>
30.	Android Studio. Управління активностями. Передача даних між активностями. Динамічне наповнення активностей віджетами. Приклади.</p>



</FONT></BODY>
</HTML>
